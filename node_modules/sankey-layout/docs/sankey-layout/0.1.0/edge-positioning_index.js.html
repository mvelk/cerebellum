<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: edge-positioning/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: edge-positioning/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Edge positioning.
 *
 * @module edge-positioning
 */

import d3 from 'd3';


export default function flowLayout() {

  function layout(G) {
    setEdgeEndpoints(G);
    setEdgeCurvatures(G);
  }

  return layout;
}


function setEdgeEndpoints(G) {
  G.nodes().forEach(u => {
    const node = G.node(u);
    let sy = 0, ty = 0;

    node.outgoing.forEach(e => {
      const edge = G.edge(e);
      edge.x0 = node.x;
      edge.y0 = node.y + sy + edge.dy / 2;
      sy += edge.dy;
    });

    node.incoming.forEach(e => {
      const edge = G.edge(e);
      edge.x1 = node.x;
      edge.y1 = node.y + ty + edge.dy / 2;
      ty += edge.dy;
    });
  });
}


function setEdgeCurvatures(G) {
  G.nodes().forEach(u => {
    const node = G.node(u);

    const outgoing = node.outgoing.map(e => G.edge(e)),
          incoming = node.incoming.map(e => G.edge(e));

    setEdgeEndCurvatures(outgoing, 'r0');
    setEdgeEndCurvatures(incoming, 'r1');
  });
}


function maximumRadiusOfCurvature(link) {
  var Dx = link.x1 - link.x0,
      Dy = link.y1 - link.y0;
  return (Dy !== 0) ? (Dx*Dx + Dy*Dy) / Math.abs(4*Dy) : Infinity;
}


function setEdgeEndCurvatures(edges, rr) {
  let jmid = null;

  // initialise edges, find reversal of curvature
  edges.forEach((edge, j) => {
    edge.Rmax = maximumRadiusOfCurvature(edge);
    edge[rr] = Math.max(edge.dy / 2, edge.Rmax * 0.6);
    if (edge.y0 &lt; edge.y1) { jmid = j; }
  });

  if (jmid !== null) {
    // Set maximum radius down from middle
    sweepEdgeCurvature(edges, rr, jmid, -1);

    // Set maximum radius up from middle
    sweepEdgeCurvature(edges, rr, jmid + 1, +1);
  }
}


function sweepEdgeCurvature(allEdges, rr, j0, direction) {
  let edges = [];
  if (direction > 0) {
    let j = j0;
    while (j &lt; allEdges.length) edges.push(allEdges[j++]);
  } else {
    let j = j0;
    while (j >= 0) edges.push(allEdges[j--]);
  }

  if (edges.length === 0) return;

  // sweep from middle out
  let Rmax = edges[0].Rmax + edges[0].dy / 2;
  edges.forEach(edge => {
    if (edge[rr] > Rmax - edge.dy/2) {
      edge[rr] = Math.max(edge.dy / 2, Rmax - edge.dy/2);
    }
    Rmax = edge[rr] - edge.dy/2;
  });

  let Rmin = 0;
  edges.reverse();
  edges.forEach(edge => {
    if (edge[rr] &lt; Rmin + edge.dy/2) {
      edge[rr] = Math.min(edge.Rmax, Rmin + edge.dy/2);
    }
    Rmin = edge[rr] + edge.dy/2;
  });
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-edge-ordering.html">edge-ordering</a></li><li><a href="module-edge-positioning.html">edge-positioning</a></li><li><a href="module-layout.html">layout</a></li><li><a href="module-node-ordering.html">node-ordering</a></li><li><a href="module-node-ordering_count-crossings.html">node-ordering/count-crossings</a></li><li><a href="module-node-positioning_justified.html">node-positioning/justified</a></li></ul><h3>Classes</h3><ul><li><a href="module-layout.html#~sankeyLayout">sankeyLayout</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Mar 03 2016 09:48:43 GMT+0000 (GMT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
