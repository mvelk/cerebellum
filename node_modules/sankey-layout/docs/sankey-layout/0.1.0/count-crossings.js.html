<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: count-crossings.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: count-crossings.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module node-ordering/count-crossings */

/**
 * Count the total number of crossings between 2 layers.
 *
 * This is the sum of the countBetweenCrossings and countLoopCrossings.
 *
 * @param {Graph} G - The graph.
 * @param {Array} orderA - List of node ids on left side.
 * @param {Array} orderB - List of node ids on right side.
 */
export default function countCrossings(G, orderA, orderB) {
  return (
    countBetweenCrossings(G, orderA, orderB) +
    countLoopCrossings(G, orderA, orderB)
  );
}

/**
 * Count the number of crossings of edges passing between 2 layers.
 *
 * Algorithm from
 * http://jgaa.info/accepted/2004/BarthMutzelJuenger2004.8.2.pdf
 *
 * @param {Graph} G - The graph.
 * @param {Array} orderA - List of node ids on left side.
 * @param {Array} orderB - List of node ids on right side.
 */
export function countBetweenCrossings(G, orderA, orderB) {

  let north, south, p, q;
  if (orderA.length > orderB.length) {
    north = orderA;
    south = orderB;
  } else {
    north = orderB;
    south = orderA;
  }

  p = north.length;
  q = south.length;

  // lexicographically sorted edges from north to south
  let southSeq = [];
  north.forEach(u => {
    south.forEach((v, j) => {
      if (G.hasEdge(u, v) || G.hasEdge(v, u)) southSeq.push(j);
    });
  });

  // build accumulator tree
  let firstIndex = 1;
  while (firstIndex &lt; q) firstIndex *= 2;
  const treeSize = 2 * firstIndex - 1;  // number of tree nodes
  firstIndex -= 1;                      // index of leftmost leaf
  let tree = new Array(treeSize).fill(0);

  // count the crossings
  let count = 0;
  southSeq.forEach(k => {
    let index = k + firstIndex;
    tree[index]++;
    while (index > 0) {
      if (index % 2) count += tree[index + 1];
      index = Math.floor((index - 1) / 2);
      tree[index]++;
    }
  });

  return count;
}

/**
 * Count the number of crossings from within-layer edges.
 *
 * @param {Graph} G - The graph.
 * @param {Array} orderA - List of node ids on left side.
 * @param {Array} orderB - List of node ids on right side.
 */
export function countLoopCrossings(G, orderA, orderB) {
  // Count crossings from edges within orderA and within orderB.
  // Only look for edges on the right of orderA (forward edges)
  // and on the left of orderB (reverse edges)

  // how many edges pass across?
  let crossA = orderA.map(d => 0),
      crossB = orderB.map(d => 0);

  orderA.forEach((u, i) => {
    G.successors(u).forEach(v => {
      if (u !== v &amp;&amp; !G.edge(u, v).reverse) {
        let index = orderA.indexOf(v);
        if (index >= 0) {
          // console.log('edge A', u, v, index, i);
          if (i > index) {
            let j = index + 1;
            while (j &lt; i) {
              crossA[j++] += 1;
            }
          } else {
            let j = i + 1;
            while (j &lt; index) {
              crossA[j++] += 1;
            }
          }
          // console.log(crossA);
        }
      }
    });
  });

  orderB.forEach((u, i) => {
    G.successors(u).forEach(v => {
      if (u !== v &amp;&amp; G.edge(u, v).reverse) {
        let index = orderB.indexOf(v);
        if (index >= 0) {
          // console.log('edge B', u, v, index, i);
          if (i > index) {
            let j = index + 1;
            while (j &lt; i) {
              crossB[j++] += 1;
            }
          } else {
            let j = i + 1;
            while (j &lt; index) {
              crossB[j++] += 1;
            }
          }
          // console.log(crossB);
        }
      }
    });
  });

  let count = 0;
  orderA.forEach((u, i) => {
    orderB.forEach((v, j) => {
      if (G.hasEdge(u, v) || G.hasEdge(v, u)) {
        count += crossA[i];
        count += crossB[j];
      }
    });
  });

  return count;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-node-ordering.html">node-ordering</a></li><li><a href="module-node-ordering_count-crossings.html">node-ordering/count-crossings</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Mar 02 2016 09:36:58 GMT+0000 (GMT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
