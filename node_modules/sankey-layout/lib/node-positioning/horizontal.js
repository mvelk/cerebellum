'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spanMinWidths = spanMinWidths;
exports.positionHorizontally = positionHorizontally;

var _lodash = require('lodash.sumby');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function spanMinWidths(G, order) {
  var widths = [];
  order.forEach(function (rank, i) {
    if (i === order.length - 1) return;
    var minWidth = 0;
    rank.forEach(function (band) {
      band.forEach(function (v) {
        G.outEdges(v).forEach(function (e) {
          var w = G.edge(e).dy,
              dy = G.node(e.w).y - G.node(e.v).y,
              ay = Math.abs(dy) - w,
              // final sign doesn't matter
          dx2 = w * w - ay * ay,
              dx = dx2 >= 0 ? Math.sqrt(dx2) : w;
          if (dx > minWidth) minWidth = dx;
        });
      });
    });
    widths.push(minWidth);
  });
  return widths;
}

function positionHorizontally(G, order, width, minWidths) {
  var totalMinWidth = (0, _lodash2.default)(minWidths);

  var dx = void 0;
  if (totalMinWidth > width) {
    // allocate fairly
    dx = minWidths.map(function (w) {
      return width * w / totalMinWidth;
    });
  } else {
    (function () {
      var spare = width - totalMinWidth;
      dx = minWidths.map(function (w) {
        return w + spare / (order.length - 1);
      });
    })();
  }

  var x = 0;
  order.forEach(function (rank, i) {
    rank.forEach(function (band) {
      band.forEach(function (u) {
        var node = G.node(u);
        node.x = x;
      });
    });
    x += dx[i];
  });
}