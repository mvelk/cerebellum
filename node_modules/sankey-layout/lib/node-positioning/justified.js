'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = justifiedPositioning;

var _lodash = require('lodash.max');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.sumby');

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require('lodash.isfunction');

var _lodash6 = _interopRequireDefault(_lodash5);

var _lodash7 = require('lodash.isarray');

var _lodash8 = _interopRequireDefault(_lodash7);

var _horizontal = require('./horizontal');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function justifiedPositioning() {
  var size = [1, 1],
      scale = null,
      separation = function separation(a, b) {
    return 1;
  },
      edgeValue = function edgeValue(e) {
    return e.data.value;
  },
      nodeDirection = function nodeDirection(n) {
    return n.data ? n.data.direction : 'r';
  },
      whitespace = 0.5;

  function position(G, order) {
    if (scale === null) position.scaleToFit(G, order);

    // set node and edge sizes
    setNodeValues(G, edgeValue, nodeDirection);
    setNodeEdgeHeights(G, edgeValue, scale);

    var bandVals = bandValues(G, order);

    // input types:
    // [ [r1b1n1, r1b1n2], [r2b1n1] ]
    // [ [ [r1b1n1], [r1b2n1] ], ...
    if (order.length > 0 && order[0].length > 0 && !(0, _lodash8.default)(order[0][0])) {
      order = order.map(function (rank) {
        return [rank];
      });
    }

    order.forEach(function (rank) {

      var y = 0;
      rank.forEach(function (band, j) {
        // Height of this band, based on fraction of value
        var bandHeight = bandVals[j] / (0, _lodash4.default)(bandVals) * size[1];

        var margin = whitespace * bandHeight / 5;
        var height = bandHeight - 2 * margin;
        var total = (0, _lodash4.default)(band, function (u) {
          return G.node(u).dy;
        });
        var gaps = band.map(function (u, i) {
          var node = G.node(u);
          if (!node.value) return 0;
          return band[i + 1] ? separation(band[i], band[i + 1], G) : 0;
        });
        var space = Math.max(0, height - total);
        var kg = (0, _lodash4.default)(gaps) ? space / (0, _lodash4.default)(gaps) : 0;

        var isFirst = true,
            isLast = true; // XXX bands

        var yy = y + margin;
        if (band.length === 1) {
          // centre vertically
          yy += (height - G.node(band[0]).dy) / 2;
        }

        var prevGap = isFirst ? Number.MAX_VALUE : 0; // edge of graph
        band.forEach(function (u, i) {
          var node = G.node(u);
          node.y = yy;
          node.spaceAbove = prevGap;
          node.spaceBelow = gaps[i] * kg;
          yy += node.dy + node.spaceBelow;
          prevGap = node.spaceBelow;

          // XXX is this a good idea?
          if (node.data && node.data.forceY !== undefined) {
            node.y = margin + node.data.forceY * (height - node.dy);
          }
        });
        if (band.length > 0) {
          G.node(band[band.length - 1]).spaceBelow = isLast ? Number.MAX_VALUE : 0; // edge of graph
        }

        y += bandHeight;
      });
    });

    // position nodes horizontally
    var minWidths = (0, _horizontal.spanMinWidths)(G, order);
    (0, _horizontal.positionHorizontally)(G, order, size[0], minWidths);

    var nodes = [];
    G.nodes().forEach(function (u) {
      var node = G.node(u);
      node.id = u;
      nodes.push(node);
    });

    return nodes;
  }

  position.scaleToFit = function (G, order) {
    setNodeValues(G, edgeValue, nodeDirection);

    var maxValue = (0, _lodash4.default)(bandValues(G, order));
    if (maxValue <= 0) {
      scale = 1;
      return;
    }

    scale = size[1] / maxValue;
    if (whitespace != 1) scale *= 1 - whitespace;
  };

  position.size = function (x) {
    if (!arguments.length) return size;
    size = x;
    return position;
  };

  position.separation = function (x) {
    if (!arguments.length) return separation;
    separation = (0, _lodash6.default)(x) ? x : function () {
      return x;
    };
    return position;
  };

  position.whitespace = function (x) {
    if (!arguments.length) return whitespace;
    whitespace = x;
    return position;
  };

  position.scale = function (x) {
    if (!arguments.length) return scale;
    scale = x;
    return position;
  };

  return position;
} /**
   * Original, full-width node positioning.
   *
   * Uses spacing and whitespace fraction to position nodes within layers.
   *
   * @module node-positioning/justified
   */

function setNodeValues(G, edgeValue, nodeDirection) {
  G.nodes().forEach(function (n) {
    var incoming = (0, _lodash4.default)(G.inEdges(n), function (e) {
      return edgeValue(G.edge(e));
    }),
        outgoing = (0, _lodash4.default)(G.outEdges(n), function (e) {
      return edgeValue(G.edge(e));
    });
    var node = G.node(n);
    if (!node) G.setNode(n, node = {});
    node.value = Math.max(incoming, outgoing);

    // also set direction
    // if (node.direction === undefined) node.direction = nodeDirection(node) || 'r';
    // XXX this is done when creating graph in the first place?
  });
}

function setNodeEdgeHeights(G, edgeValue, scale) {
  G.nodes().forEach(function (n) {
    var node = G.node(n);
    node.dy = node.value * scale;
  });

  G.edges().forEach(function (e) {
    var edge = G.edge(e);
    edge.value = edgeValue(edge);
    edge.dy = edge.value * scale;
  });
}

function bandValues(G, order) {
  if (order.length === 0 || order[0].length === 0) return [];
  if (!(0, _lodash8.default)(order[0][0])) {
    order = order.map(function (rank) {
      return [rank];
    });
  }

  var Nr = order.length,
      Nb = order[0].length;

  var values = new Array(Nb);
  for (var i = 0; i < Nb; i++) {
    values[i] = 0;
  }order.forEach(function (rank) {
    rank.forEach(function (band, j) {
      var total = (0, _lodash4.default)(band, function (u) {
        return G.node(u).value;
      });
      values[j] = Math.max(values[j], total);
    });
  });

  return values;
}