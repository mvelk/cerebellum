"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = countCrossings;
exports.countBetweenCrossings = countBetweenCrossings;
exports.countLoopCrossings = countLoopCrossings;
/** @module node-ordering/count-crossings */

/**
 * Count the total number of crossings between 2 layers.
 *
 * This is the sum of the countBetweenCrossings and countLoopCrossings.
 *
 * @param {Graph} G - The graph.
 * @param {Array} orderA - List of node ids on left side.
 * @param {Array} orderB - List of node ids on right side.
 */
function countCrossings(G, orderA, orderB) {
  return countBetweenCrossings(G, orderA, orderB) //+
  // countLoopCrossings(G, orderA, orderB)
  ;
}

/**
 * Count the number of crossings of edges passing between 2 layers.
 *
 * Algorithm from
 * http://jgaa.info/accepted/2004/BarthMutzelJuenger2004.8.2.pdf
 *
 * @param {Graph} G - The graph.
 * @param {Array} orderA - List of node ids on left side.
 * @param {Array} orderB - List of node ids on right side.
 */
function countBetweenCrossings(G, orderA, orderB) {

  var north = void 0,
      south = void 0,
      p = void 0,
      q = void 0;
  if (orderA.length > orderB.length) {
    north = orderA;
    south = orderB;
  } else {
    north = orderB;
    south = orderA;
  }

  p = north.length;
  q = south.length;

  // lexicographically sorted edges from north to south
  var southSeq = [];
  north.forEach(function (u) {
    south.forEach(function (v, j) {
      if (G.hasEdge(u, v) || G.hasEdge(v, u)) southSeq.push(j);
    });
  });

  // build accumulator tree
  var firstIndex = 1;
  while (firstIndex < q) {
    firstIndex *= 2;
  }var treeSize = 2 * firstIndex - 1; // number of tree nodes
  firstIndex -= 1; // index of leftmost leaf

  var tree = new Array(treeSize);
  for (var i = 0; i < treeSize; i++) {
    tree[i] = 0;
  } // count the crossings
  var count = 0;
  southSeq.forEach(function (k) {
    var index = k + firstIndex;
    tree[index]++;
    while (index > 0) {
      if (index % 2) count += tree[index + 1];
      index = Math.floor((index - 1) / 2);
      tree[index]++;
    }
  });

  return count;
}

/**
 * Count the number of crossings from within-layer edges.
 *
 * @param {Graph} G - The graph.
 * @param {Array} orderA - List of node ids on left side.
 * @param {Array} orderB - List of node ids on right side.
 */
function countLoopCrossings(G, orderA, orderB) {
  // Count crossings from edges within orderA and within orderB.
  // Only look for edges on the right of orderA (forward edges)
  // and on the left of orderB (reverse edges)

  // how many edges pass across?
  var crossA = orderA.map(function (d) {
    return 0;
  }),
      crossB = orderB.map(function (d) {
    return 0;
  });

  orderA.forEach(function (u, i) {
    G.outEdges(u).forEach(function (e) {
      if (e.v !== e.w && !G.edge(e).reverse) {
        var index = orderA.indexOf(e.w);
        if (index >= 0) {
          if (i > index) {
            var j = index + 1;
            while (j < i) {
              crossA[j++] += 1;
            }
          } else {
            var _j = i + 1;
            while (_j < index) {
              crossA[_j++] += 1;
            }
          }
        }
      }
    });
  });

  orderB.forEach(function (u, i) {
    G.outEdges(u).forEach(function (e) {
      if (e.v !== e.w && G.edge(e).reverse) {
        var index = orderB.indexOf(e.w);
        if (index >= 0) {
          if (i > index) {
            var j = index + 1;
            while (j < i) {
              crossB[j++] += 1;
            }
          } else {
            var _j2 = i + 1;
            while (_j2 < index) {
              crossB[_j2++] += 1;
            }
          }
        }
      }
    });
  });

  var count = 0;
  orderA.forEach(function (u, i) {
    orderB.forEach(function (v, j) {
      var N = G.nodeEdges(u, v).length;
      count += N * (crossA[i] + crossB[j]);
    });
  });

  return count;
}