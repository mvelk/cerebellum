'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

exports.medianValue = medianValue;
exports.default = sortNodes;
exports.neighbourPositions = neighbourPositions;
exports.sortByPositions = sortByPositions;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function medianValue(positions) {
  var m = Math.floor(positions.length / 2);
  if (positions.length === 0) {
    return -1;
  } else if (positions.length % 2 === 1) {
    return positions[m];
  } else if (positions.length === 2) {
    return (positions[0] + positions[1]) / 2;
  } else {
    var left = positions[m - 1] - positions[0],
        right = positions[positions.length - 1] - positions[m];
    return (positions[m - 1] * right + positions[m] * left) / (left + right);
  }
};

function sortNodes(G, order) {
  var sweepDirection = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
  var includeLoops = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

  if (sweepDirection > 0) {
    var _loop = function _loop(r) {
      var medians = new _map2.default();
      // console.group('median rank', r, sweepDirection);
      // console.log(order[r]);
      order[r].forEach(function (u) {
        var neighbour = medianValue(neighbourPositions(G, order, r, r - 1, u, includeLoops));
        // console.log(u, neighbour);
        medians.set(u, neighbour);
      });
      // order[r].sort((a, b) => medians.get(a) - medians.get(b));
      sortByPositions(order[r], medians);
      // console.log(order[r]);
      // console.groupEnd();
      // if (r === 3) console.log('rank 3 ->', Array.from(medians));
      // if (r === 4) console.log('bf ->', neighbourPositions(G, order, r, r - 1, 'bf'));
    };

    for (var r = 1; r < order.length; ++r) {
      _loop(r);
    }
  } else {
      var _loop2 = function _loop2(_r) {
        var medians = new _map2.default();
        // console.group('median rank', r, sweepDirection);
        // console.log(order[r]);
        order[_r].forEach(function (u) {
          var neighbour = medianValue(neighbourPositions(G, order, _r, _r + 1, u, includeLoops));
          // console.log(u, neighbour);
          medians.set(u, neighbour);
        });
        // order[r].sort((a, b) => medians.get(a) - medians.get(b));
        sortByPositions(order[_r], medians);
        // console.log(order[r]);
        // console.groupEnd();
        // if (r === 3) console.log('rank 3 <-', Array.from(medians));
        // if (r === 4) console.log('bf <-', neighbourPositions(G, order, r, r + 1, 'bf'));
      };

      for (var _r = order.length - 2; _r >= 0; --_r) {
        _loop2(_r);
      }
    }
};

function neighbourPositions(G, order, i, j, u) {
  var includeLoops = arguments.length <= 5 || arguments[5] === undefined ? false : arguments[5];

  // current rank i
  // neighbour rank j
  var thisRank = order[i],
      otherRank = order[j];

  var positions = [];

  // neighbouring positions on other rank
  otherRank.forEach(function (n, i) {
    if (G.nodeEdges(n, u).length > 0) {
      positions.push(i);
    }
  });

  if (positions.length === 0 && includeLoops) {
    // if no neighbours in other rank, look for loops to this rank
    // XXX only on one side?
    // console.log('loops:', u);
    thisRank.forEach(function (n, i) {
      if (G.nodeEdges(n, u).length > 0) {
        positions.push(i + 0.5);
        console.log('   ', n, i);
      }
    });
  }

  positions.sort(function (a, b) {
    return a - b;
  });

  return positions;
}

/**
 * Sort arr according to order. -1 in order means stay in same position.
 */
function sortByPositions(arr, order) {
  var origOrder = new _map2.default(arr.map(function (d, i) {
    return [d, i];
  }));

  // console.log('sorting', arr, order, origOrder);
  for (var i = 1; i < arr.length; ++i) {
    // console.group('start', i, arr[i]);
    for (var k = i; k > 0; --k) {

      var j = k - 1,
          a = order.get(arr[j]),
          b = order.get(arr[k]);

      // count back over any fixed positions (-1)
      while ((a = order.get(arr[j])) === -1 && j > 0) {
        j--;
      } // console.log(j, k, arr[j], arr[k], a, b);
      if (b === -1 || a === -1) {
        // console.log('found -1', a, b, 'skipping', j, k);
        break;
      }

      if (a === b) {
        a = origOrder.get(arr[j]);
        b = origOrder.get(arr[k]);
        // console.log('a == b, switching to orig order', a, b);
      }

      if (b >= a) {
        // console.log('k > k -1, stopping');
        break;
      }
      // console.log('swapping', arr[k], arr[j]);
      // swap arr[k], arr[j]

      // console.log(arr);
      var _ref = [arr[j], arr[k]];
      arr[k] = _ref[0];
      arr[j] = _ref[1];
    }
    // console.groupEnd();
  }
  // console.log('-->', arr);
}