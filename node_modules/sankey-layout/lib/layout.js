'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sankeyLayout;

var _utils = require('./utils');

var _rankAssignment = require('./rank-assignment');

var _rankAssignment2 = _interopRequireDefault(_rankAssignment);

var _addDummyNodes = require('./add-dummy-nodes');

var _addDummyNodes2 = _interopRequireDefault(_addDummyNodes);

var _nodeOrdering = require('./node-ordering');

var _nodeOrdering2 = _interopRequireDefault(_nodeOrdering);

var _justified = require('./node-positioning/justified');

var _justified2 = _interopRequireDefault(_justified);

var _edgeOrdering = require('./edge-ordering');

var _edgeOrdering2 = _interopRequireDefault(_edgeOrdering);

var _edgePositioning = require('./edge-positioning');

var _edgePositioning2 = _interopRequireDefault(_edgePositioning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sankey layout
 * @constructor sankeyLayout
 */
function sankeyLayout() {

  var nodeLayout = (0, _justified2.default)(),
      edgeLayout = (0, _edgePositioning2.default)();

  var nodes = [],
      links = [],
      order = null;

  /**
   * Layout the diagram described by the graph G.
   * @method sankeyLayout
   * @param G {Graph} - The input graph. Nodes must have `rank` attributes.
   * Edges must have `value` attributes.
   */
  function layout() {
    var linksIn = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
    var nodesIn = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
    var data = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];


    var G = (0, _utils.createGraph)(nodesIn, linksIn);

    if (data.order == null) {
      // Assign ranks
      (0, _rankAssignment2.default)(G, data.rankSets || []);
      (0, _addDummyNodes2.default)(G);

      // Assign orders within ranks
      order = (0, _nodeOrdering2.default)(G);
    } else {
      // filter order to only include known nodes
      order = data.order.map(function (bands) {
        return bands.map(function (nodes) {
          return nodes.filter(function (n) {
            return G.node(n) !== undefined;
          });
        });
      });
    }

    // Position and scale nodes within ranks
    nodes = nodeLayout(G, order);

    // Order incoming and outgoing edges at each node
    (0, _edgeOrdering2.default)(G, { alignLinkTypes: data.alignLinkTypes || false });

    // Position edges and calculate curvatures
    links = edgeLayout(G);
  }

  /* **************************************************/
  /* nodeLayout methods *******************************/
  /* **************************************************/

  layout.nodes = function () {
    return nodes;
  };

  layout.links = function () {
    return links;
  };

  layout.order = function () {
    return order;
  };

  /**
   * Set size of layout.
   * @method size
   * @param size {[width, height]} - size
   * @returns {sankeyLayout|Number[]}
   */
  layout.size = function (x) {
    if (!arguments.length) return nodeLayout.size();
    nodeLayout.size(x);
    return layout;
  };

  layout.separation = function (x) {
    if (!arguments.length) return nodeLayout.separation();
    nodeLayout.separation(x);
    return layout;
  };

  layout.whitespace = function (x) {
    if (!arguments.length) return nodeLayout.whitespace();
    nodeLayout.whitespace(x);
    return layout;
  };

  layout.edgeValue = function (_x) {
    if (!arguments.length) return nodeLayout.edgeValue();
    nodeLayout.edgeValue(_x);
    return layout;
  };

  layout.scale = function (x) {
    if (!arguments.length) return nodeLayout.scale();
    nodeLayout.scale(x);
    return layout;
  };

  return layout;
} /**
   * Sankey layout
   *
   * @module layout
   */