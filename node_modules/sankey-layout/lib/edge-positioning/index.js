'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = linkLayout;

var _utils = require('./utils');

function linkLayout() {

  function layout(G) {
    setEdgeEndpoints(G);
    setEdgeCurvatures(G);

    var edges = [];
    G.edges().forEach(function (e) {
      var edge = G.edge(e);
      edge.id = e.v + '-' + e.w + '-' + e.name;
      edges.push(edge);
    });

    return edges;
  }

  return layout;
} /**
   * Edge positioning.
   *
   * @module edge-positioning
   */

function setEdgeEndpoints(G) {
  G.nodes().forEach(function (u) {
    var node = G.node(u);
    var sy = 0,
        ty = 0;

    node.outgoing.forEach(function (e) {
      var edge = G.edge(e);
      edge.x0 = node.x;
      edge.y0 = node.y + sy + edge.dy / 2;
      edge.d0 = node.direction || 'r';
      sy += edge.dy;
    });

    node.incoming.forEach(function (e) {
      var edge = G.edge(e);
      edge.x1 = node.x;
      edge.y1 = node.y + ty + edge.dy / 2;
      edge.d1 = node.direction || 'r';
      ty += edge.dy;
    });
  });
}

function setEdgeCurvatures(G) {
  G.nodes().forEach(function (u) {
    var node = G.node(u);

    var outgoing = node.outgoing.map(function (e) {
      return G.edge(e);
    }),
        incoming = node.incoming.map(function (e) {
      return G.edge(e);
    });

    outgoing.sort(function (a, b) {
      return a.y0 - b.y0;
    });
    incoming.sort(function (a, b) {
      return a.y1 - b.y1;
    });

    setEdgeEndCurvatures(outgoing, 'r0');
    setEdgeEndCurvatures(incoming, 'r1');
  });
}

function maximumRadiusOfCurvature(link) {
  var Dx = link.x1 - link.x0,
      Dy = link.y1 - link.y0;
  if (link.d0 !== link.d1) {
    return Math.abs(Dy) / 2.1;
  } else {
    return Dy !== 0 ? (Dx * Dx + Dy * Dy) / Math.abs(4 * Dy) : Infinity;
  }
}

function setEdgeEndCurvatures(edges, rr) {
  // initialise edges, find reversal of curvature
  edges.forEach(function (edge, j) {
    edge.Rmax = maximumRadiusOfCurvature(edge);
    edge[rr] = Math.max(edge.dy / 2, edge.d0 === edge.d1 ? edge.Rmax * 0.6 : 5 + edge.dy / 2);
  });

  var jmid = rr === 'r0' ? (0, _utils.findFirst)(edges, function (f) {
    return f.y1 > f.y0;
  }) : (0, _utils.findFirst)(edges, function (f) {
    return f.y0 > f.y1;
  });
  if (jmid === null) jmid = edges.length;

  // Set maximum radius down from middle
  (0, _utils.sweepCurvatureInwards)(edges.slice(jmid), rr);

  // Set maximum radius up from middle
  if (jmid > 0) {
    var edges2 = [];
    for (var j = jmid - 1; j >= 0; j--) {
      edges2.push(edges[j]);
    }(0, _utils.sweepCurvatureInwards)(edges2, rr);
  }
}