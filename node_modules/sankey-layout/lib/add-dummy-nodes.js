'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.default = addDummyNodes;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addDummyNodes(G) {
  // Loop through edges, looking for ones longer than one rank gap
  G.edges().forEach(function (e) {
    var V = G.node(e.v),
        W = G.node(e.w);
    var r = V.rank,
        id = void 0,
        dummyRanks = [];

    if (r + 1 <= W.rank) {
      // add more to get forwards
      if (V.direction === 'l') dummyRanks.push(r); // turn around
      while (++r < W.rank) {
        dummyRanks.push(r);
      }
      if (W.direction === 'l') dummyRanks.push(r); // turn around
      replaceEdge(G, e, dummyRanks, 'r');
    } else if (r > W.rank) {
      // add more to get backwards
      if (V.direction !== 'l') dummyRanks.push(r); // turn around
      while (r-- > W.rank + 1) {
        dummyRanks.push(r);
      }
      if (W.direction !== 'l') dummyRanks.push(r); // turn around
      replaceEdge(G, e, dummyRanks, 'l');
    }
  });

  return G;
}

function replaceEdge(G, oldEdge, dummyRanks, direction) {
  if (dummyRanks.length === 0) return;

  var dummies = dummyRanks.map(function (r) {
    var id = '__' + oldEdge.v + '_' + oldEdge.w + '_' + r;
    G.setNode(id, { rank: r, dummy: true, data: null, direction: direction });
    return id;
  });

  var nn = [oldEdge.v].concat((0, _toConsumableArray3.default)(dummies), [oldEdge.w]);
  nn.forEach(function (n, i) {
    if (i + 1 < nn.length) G.setEdge(nn[i], nn[i + 1], {
      source: G.node(oldEdge.v),
      target: G.node(oldEdge.w),
      data: G.edge(oldEdge).data
    }, oldEdge.name);
  });

  G.removeEdge(oldEdge);
}