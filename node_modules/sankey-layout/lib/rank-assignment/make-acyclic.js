'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

exports.default = makeAcyclic;
exports.findSpanningTree = findSpanningTree;
exports.nodeRelationship = nodeRelationship;

var _graphlib = require('graphlib');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Reverse edges in G to make it acyclic
 */
function makeAcyclic(G, v0) {

  var tree = findSpanningTree(G, v0);

  G.edges().forEach(function (e) {
    var rel = nodeRelationship(tree, e.v, e.w);
    if (rel < 0) {
      var label = G.edge(e) || {};
      label.reversed = true;
      G.removeEdge(e);
      G.setEdge(e.w, e.v, label);
    }
  });

  return G;
}

// find spanning tree, starting from the given node.
// return new graph where nodes have depth and thread
function findSpanningTree(G, v0) {
  var visited = new _set2.default();
  var tree = new _graphlib.Graph({ directed: true });
  var thread = [];

  if (!G.hasNode(v0)) throw Error('node not in graph');

  doDfs(G, v0, visited, tree, thread);
  G.nodes().forEach(function (u) {
    if (!visited.has(u)) {
      // console.log('missed visiting', u);
      doDfs(G, u, visited, tree, thread);
    }
  });

  thread.forEach(function (u, i) {
    tree.node(u).thread = i + 1 < thread.length ? thread[i + 1] : thread[0];
  });

  return tree;
}

/**
 * Returns 1 if w is a descendent of v, -1 if v is a descendent of w, and 0 if
 * they are unrelated.
 */
function nodeRelationship(tree, v, w) {
  var V = tree.node(v),
      W = tree.node(w);
  if (V.depth < W.depth) {
    var u = V.thread; // next node
    while (tree.node(u).depth > V.depth) {
      if (u === w) return 1;
      u = tree.node(u).thread;
    }
  } else if (W.depth < V.depth) {
    var _u = W.thread; // next node
    while (tree.node(_u).depth > W.depth) {
      if (_u === v) return -1;
      _u = tree.node(_u).thread;
    }
  }
  return 0;
}

function doDfs(G, v, visited, tree, thread) {
  var depth = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];

  if (!visited.has(v)) {
    visited.add(v);
    thread.push(v);
    tree.setNode(v, { depth: depth });

    // It doesn't seem to cause a problem with letters as node ids, but numbers
    // are sorted when using G.successors(). So use G.outEdges() instead.
    var next = G.outEdges(v).map(function (e) {
      return e.w;
    });
    next.forEach(function (w, i) {
      if (!visited.has(w)) {
        tree.setEdge(v, w, { delta: 1 });
      }
      doDfs(G, w, visited, tree, thread, depth + 1);
    });
  }
}

// find spanning tree, starting from the given node.
// - follow normal edges forwards
// - follow reverse edges backwards
// return forward and reverse edges
function dfs(g, vs, order, cb) {
  if (!_.isArray(vs)) {
    vs = [vs];
  }

  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);

  var visited = {};
  _.each(vs, function (v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }

    doDfs(g, v, order === "post", visited, navigation, cb);
  });
}