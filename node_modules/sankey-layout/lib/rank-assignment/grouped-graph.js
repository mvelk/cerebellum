'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.default = groupedGraph;

var _graphlib = require('graphlib');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create a new graph where nodes in the same rank set are merged into one node.
 *
 * Depends on the "direction" attribute of the nodes in G, and the "delta"
 * atribute of the edges.
 *
 */
function groupedGraph(G, rankSets) {
  // Not multigraph because this is only used for calculating ranks
  var GG = new _graphlib.Graph({ directed: true });

  // Make sure there is a minimum-rank set
  var Smin = false;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(rankSets), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var set = _step.value;

      if (set.type === 'min') {
        Smin = true;
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (!Smin) {
    // find the first source node
    var sources = G.sources();
    if (sources.length > 0) {
      rankSets = [{ type: 'min', nodes: [sources[0]] }].concat((0, _toConsumableArray3.default)(rankSets));
    } else {
      // no sources, just use the first nodes
      rankSets = [{ type: 'min', nodes: [G.nodes()[0]] }].concat((0, _toConsumableArray3.default)(rankSets));
    }
  }

  // Construct map of node ids to the set they are in, if any
  var nodeSets = new _map2.default();
  var i = 0;
  rankSets.forEach(function (set) {
    if (!set.nodes || set.nodes.length === 0) return;
    var id = '' + i++;
    set.nodes.forEach(function (n) {
      nodeSets.set(n, id);
    });
    GG.setNode(id, { type: set.type, nodes: set.nodes });
  });

  G.nodes().forEach(function (u) {
    if (!nodeSets.has(u)) {
      var id = '' + i++;
      var set = { type: 'same', nodes: [u] };
      nodeSets.set(u, id);
      GG.setNode(id, set);
    }
  });

  // Add edges between nodes/groups
  G.edges().forEach(function (e) {
    var source = nodeSets.has(e.v) ? nodeSets.get(e.v) : e.v,
        target = nodeSets.has(e.w) ? nodeSets.get(e.w) : e.w;

    // Minimum edge length depends on direction of nodes:
    //  -> to -> : 1
    //  -> to <- : 0
    //  <- to -> : 0 (in opposite direction??)
    //  <- to <- : 1 in opposite direction
    var V = G.node(e.v) || {},
        W = G.node(e.w) || {};

    var edge = GG.edge(source, target) || { delta: 0 };
    if (source === target) {
      edge.delta = 0;
      GG.setEdge(source, target, edge);
    } else if (V.direction === 'l') {
      edge.delta = Math.max(edge.delta, W.direction === 'l' ? 1 : 0);
      GG.setEdge(target, source, edge);
    } else {
      edge.delta = Math.max(edge.delta, W.direction === 'l' ? 0 : 1);
      GG.setEdge(source, target, edge);
    }
  });

  return GG;
}