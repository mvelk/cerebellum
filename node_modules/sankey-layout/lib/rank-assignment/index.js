'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assignRanks;

var _lodash = require('lodash.min');

var _lodash2 = _interopRequireDefault(_lodash);

var _groupedGraph = require('./grouped-graph');

var _groupedGraph2 = _interopRequireDefault(_groupedGraph);

var _makeAcyclic = require('./make-acyclic');

var _makeAcyclic2 = _interopRequireDefault(_makeAcyclic);

var _initialRank = require('./initial-rank');

var _initialRank2 = _interopRequireDefault(_initialRank);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Assign ranks to the nodes in G, according to rankSets.
 */
function assignRanks(G, rankSets) {
  if (G.nodes().length === 0) return;

  // Group nodes together, and add additional edges from Smin to sources
  var GG = (0, _groupedGraph2.default)(G, rankSets);

  // Add additional edges from Smin to sources
  addTemporaryEdges(GG);

  // Make the graph acyclic
  (0, _makeAcyclic2.default)(GG, '0');

  // Assign the initial ranks
  (0, _initialRank2.default)(GG);

  // XXX improve initial ranking...
  moveSourcesRight(GG);

  // Apply calculated ranks to original graph
  G.nodes().forEach(function (u) {
    if (!G.node(u)) G.setNode(u, {});
  });

  GG.nodes().forEach(function (u) {
    var node = GG.node(u);
    node.nodes.forEach(function (v) {
      G.node(v).rank = node.rank;
    });
  });
}

function addTemporaryEdges(GG) {
  // Add temporary edges between Smin and sources
  GG.sources().forEach(function (u) {
    if (u !== '0') {
      GG.setEdge('0', u, { temp: true, delta: 0 });
    }
  });

  // XXX Should also add edges from sinks to Smax

  // G.nodes().forEach(u => {
  //   if (!nodeSets.has(u)) {
  //     GG.
  //   }
  // });
}

function moveSourcesRight(GG) {
  GG.edges().forEach(function (e) {
    var edge = GG.edge(e);
    if (edge.temp) moveRight(e.w);
  });

  function moveRight(v) {
    var V = GG.node(v);
    var rank = (0, _lodash2.default)(GG.outEdges(v).map(function (e) {
      return GG.node(e.w).rank - GG.edge(e).delta;
    }));
    if (rank !== undefined) V.rank = rank;
  }
}