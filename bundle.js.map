{"version":3,"sources":["webpack:///webpack/bootstrap 13380fa0475fbfc851dc","webpack:///./lib/entry.js","webpack:///./lib/data.js","webpack:///./lib/model.js","webpack:///./lib/matrix.js","webpack:///./lib/activation.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,EAAC;;;;;;;AC9BD;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACjBA;AACA;;AAEA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA0D;AAC1D,4EAA2E;AAC3E,sEAAqE;;AAErE;AACA;AACA;AACA,gCAA+B,OAAO;AACtC,6CAA4C;AAC5C,8BAA6B;AAC7B,gDAA+C;AAC/C,4BAA2B;AAC3B,gEAA+D;AAC/D,oDAAmD;AACnD;AACA;AACA;;AAEA;AACA;AACA,yEAAwE;AACxE,oDAAmD;AACnD,6BAA4B;AAC5B;;AAEA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnIA;;AAEA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,YAAY;AAC/B,sBAAqB,cAAc;AACnC;AACA,wBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,YAAY;AAC/B,sBAAqB,YAAY;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,YAAY;AAC/B,sBAAqB,YAAY;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,YAAY;AAC/B,sBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B,sBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC3KA;AACA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 13380fa0475fbfc851dc","const getImageData = require(\"./data.js\");\nconst Model = require(\"./model.js\");\nconst Activation = require(\"./activation\");\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  // create elements\n\n  let canvas = document.getElementById(\"myCanvas\");\n  let ctx = canvas.getContext(\"2d\");\n  let image = document.createElement(\"img\");\n\n  // set img source\n  let imgSrc = \"../images/sample_data1.jpg\";\n  image.src = imgSrc;\n\n  // define canvas size\n  let canvasWidth = 500;\n  let canvasHeight = 500;\n  canvas.width = canvasWidth;\n  canvas.height = canvasHeight;\n\n  // on image load, draw image then sample pixel data\n  image.addEventListener(\"load\", function () {\n    ctx.drawImage(image, 0, 0, canvasWidth, canvasHeight);\n    let dataset = getImageData(ctx, 1000);\n    let model = new Model([2,2,1], dataset, Activation[\"sigmoid\"], 0.3);\n    model.iterate();\n    window.model = model;\n  });\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/entry.js\n// module id = 0\n// module chunks = 0","const getImageData = (ctx, n) => {\n    let dataset = [];\n    let topLeftPixel = ctx.getImageData(0, 0, 1, 1).data;\n    let zeroColor = topLeftPixel[0] + topLeftPixel[1] + topLeftPixel[2];\n\n    // sample color data from n random pixels\n    for (let i = 0; i < n; i++) {\n      let x = Math.floor(Math.random() * 500);\n      let y = Math.floor(Math.random() * 500);\n      let pixelData = ctx.getImageData(x, y, 1, 1).data;\n      let color = pixelData[0] + pixelData[1] + pixelData[2];\n      let group = color == zeroColor ? 0 : 1;\n      dataset.push([x, y, group]);\n    }\n    return dataset;\n};\n\nmodule.exports = getImageData;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/data.js\n// module id = 1\n// module chunks = 0","\"use strict\";\nconst Matrix = require(\"./matrix\");\n\nclass Model {\n  constructor(model,data,activationF,learningRate) {\n    this.model = model; // the number of neurons in each layer, counting input and output layers\n    this.length = model.length;\n    this.data = new Matrix(data);\n    this.y = this.data.getCols(0,1);\n    this.x = this.data.getCols(1,this.data.m);\n    this.x = this.x.transpose();\n    this.N = this.data.n; // number of observations\n    this.activationF = activationF;\n    this.learningRate = learningRate;\n\n    this.weightMatrices = this.createWeightMatrices();\n  }\n\n  createWeightMatrices() {\n    let weightMatrices = [];\n    // for each later, we need to map a_n (i elements) to a_n+1 (j elements)\n    // we multiply A_n*a_n = a_n+1, so the matrix A_n is j x i\n    // we add one to a_n i to account for the bias term being added\n    for (var i = 0; i < this.length-1; i++) {\n      weightMatrices.push(Matrix.randomMatrix(this.model[i+1],this.model[i]+1));\n    }\n    return weightMatrices;\n  }\n\n  iterate() {\n    // accumulator for deltas of each layer\n    let accumulator = this.getAccum();\n    let layerValues;\n    // forward and back prop for each observation\n    for (var i = 0; i < this.y.n; i++) {\n      layerValues = this.forwardProp(i);\n      accumulator = this.backProp(accumulator,layerValues,i);\n    }\n    this.incrementWeights(accumulator);\n  }\n\n  // creates array of vectors of 0s matching model with bias\n  getAccum() {\n    let accum = [];\n    let weightMatrix;\n    for (var i = 0; i < this.length-1; i++) {\n      weightMatrix = this.weightMatrices[i];\n      accum.push(Matrix.emptyMatrix(weightMatrix.n,weightMatrix.m));\n    }\n    return accum;\n  }\n\n  // conducts forward prop for observation n, returns all neuron layers as 2D array\n  forwardProp(n) {\n    let layer = this.x.getCols(n,n+1);\n    let layerValues = [layer];\n    let weightMatrix;\n    // calculates each layer\n    for (var i = 0; i < this.length-1; i++) {\n      weightMatrix = this.weightMatrices[i];\n      layer = this.forwardLayer(weightMatrix,layer);\n      layerValues.push(layer);\n    }\n    return layerValues;\n  }\n\n  // a^n = g(A^n-1*(a^n-1 + bias))\n  forwardLayer(weightMatrix,prevLayer) {\n    let prevWithBias = prevLayer.addBias();\n    let product = weightMatrix.multiply(prevWithBias);\n    let nextLayer = product.elementWiseFunction(this.activationF);\n    return nextLayer;\n  }\n\n  backProp(accumulator,layerValues,n) {\n    let currentY = this.y.getRows(n,n+1);\n    // final layer: d^n = a^n - y\n    let d = layerValues[this.length-1].subtract(currentY); // d^i+1\n    let daT = d.multiply(layerValues[this.length-2].addBias().transpose()); // d^i+1 * (a^i)T\n    accumulator[this.length-2] = accumulator[this.length-2].add(daT); // D_ij = D_ij + a_j * d_i\n\n    // other layers: d^n = (A^n)T * d^n+1 * (a^n . (1 - a^n)), stop at input layer\n    let weightMatrix;\n    let layer;\n    for (var i = this.length-2; i > 0; i--) {\n      weightMatrix = this.weightMatrices[i]; // A^n\n      layer = layerValues[i]; // a^n\n      d = this.backLayer(weightMatrix,d,layer); // d^n = backLayer(A^n,d^n+1,a^n)\n      d = d.getRows(1,d.n); // removing the first entry, corresponding to bias of current layer\n      daT = d.multiply(layerValues[i-1].addBias().transpose()); // D_ij = D_ij + a_j * d_i\n      accumulator[i-1] = accumulator[i-1].add(daT); // D_ij = D_ij + a_j * d_i\n    }\n    return accumulator;\n  }\n\n  // other layers: d^n = (A^n)T * d^n+1 * (a^n . (1 - a^n))\n  backLayer(weightMatrix,d,layer) {\n    let dG = layer.dotProduct(Matrix.vector(layer.n,1).subtract(layer)); // (a^n . (1 - a^n))\n    let ATd = weightMatrix.transpose().multiply(d); // (A^n)T * d^n+1\n    return ATd.multiply(dG); // (A^n)T * d^n+1 * (a^n . (1 - a^n))\n  }\n\n  // increments weights according to accumulator\n  incrementWeights(accumulator,layerValues) {\n    let increment;\n    for (var i = 0; i < this.length-1; i++) {\n      increment = accumulator[i].elementWiseFunction(n => this.learningRate*n/this.N);\n      this.weightMatrices[i] = this.weightMatrices[i].subtract(increment);\n    }\n  }\n\n  // used to render fitted graphs\n  // takes in an array of x values [x_1, x_2...], returns layer values\n  modelFunction(data){\n    let layer = [];\n    for (var i = 0; i < data.length; i++) {\n      layer.push([data[i]]);\n    }\n    layer = new Matrix(layer);\n    let layerValues = [layer];\n    let weightMatrix;\n    // calculates each layer\n    for (var i = 0; i < this.length-1; i++) {\n      weightMatrix = this.weightMatrices[i];\n      layer = this.forwardLayer(weightMatrix,layer);\n      layerValues.push(layer);\n    }\n    return layerValues[layerValues.length-1];\n  }\n}\n\nmodule.exports = Model;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model.js\n// module id = 2\n// module chunks = 0","\"use strict\";\n\nclass Matrix {\n  constructor(array) {\n    this.array = array; // [[1,2,3],[4,5,6]]\n    this.n = array.length;\n    this.m = array[0].length;\n  }\n\n  canMultiply(matrix) {\n    return this.m === matrix.n;\n  }\n\n  multiply(matrix) {\n    if (!this.canMultiply(matrix)) {\n      throw \"Can't multiply, incorrect dimensions\";\n    }\n\n    let sum;\n    let newMatrix = Matrix.emptyMatrix(this.n,matrix.m);\n    for (var i = 0; i < this.n; i++) {\n      for (var j = 0; j < matrix.m; j++) {\n        sum = 0;\n        for (var k = 0; k < this.m; k++) {\n          sum += this.array[i][k]*matrix.array[k][j];\n        }\n        newMatrix.array[i][j] = sum;\n      }\n    }\n\n    return newMatrix;\n  }\n\n  canArithmetic(matrix) {\n    return this.n === matrix.n && this.m === matrix.m;\n  }\n\n  add(matrix){\n    if (!this.canArithmetic(matrix)) {\n      throw \"Can't add, incorrect dimensions\";\n    }\n\n    let newMatrix = Matrix.emptyMatrix(this.n,this.m);\n    for (var i = 0; i < this.n; i++) {\n      for (var j = 0; j < this.m; j++) {\n        newMatrix.array[i][j] = this.array[i][j] + matrix.array[i][j];\n      }\n    }\n\n    return newMatrix;\n  }\n\n  subtract(matrix){\n    if (!this.canArithmetic(matrix)) {\n      throw \"Can't subtract, incorrect dimensions\";\n    }\n\n    let newMatrix = Matrix.emptyMatrix(this.n,this.m);\n    for (var i = 0; i < this.n; i++) {\n      for (var j = 0; j < this.m; j++) {\n        newMatrix.array[i][j] = this.array[i][j] - matrix.array[i][j];\n      }\n    }\n\n    return newMatrix;\n  }\n\n  //same as slice but slices columns\n  getCols(a,b) {\n    let cols = [];\n    for (var i = 0; i < this.n; i++) {\n      cols.push(this.array[i].slice(a,b));\n    }\n    return new Matrix(cols);\n  }\n\n  //same as slice but slices rows\n  getRows(a,b) {\n    if (a < 0 || b > this.n) {\n      throw \"Can't get rows, invalid row numbers\";\n    }\n    let rows = []\n    for (var i = a; i < b; i++) {\n      rows.push(this.array[i]);\n    }\n    return new Matrix(rows);\n  }\n\n  transpose() {\n    let newMatrix = Matrix.emptyMatrix(this.m,this.n);\n    for (var i = 0; i < this.n; i++) {\n      for (var j = 0; j < this.m; j++) {\n        newMatrix.array[j][i] = this.array[i][j];\n      }\n    }\n    return newMatrix;\n  }\n\n  // calls fn for each element of matrix and returns matrix of new values\n  elementWiseFunction(fn) {\n    let newMatrix = Matrix.emptyMatrix(this.n,this.m);\n    for (var i = 0; i < this.n; i++) {\n      for (var j = 0; j < this.m; j++) {\n        newMatrix.array[i][j] = fn(this.array[i][j]);\n      }\n    }\n    return newMatrix;\n  }\n\n  canDot(matrix) {\n    return this.m === 1 && matrix.m === 1 && this.n === matrix.n;\n  }\n\n  dotProduct(matrix) {\n    if (!this.canDot(matrix)){\n      throw \"Can't find dot product, incorrect dimensions\";\n    }\n    let sum = 0;\n    for (var i = 0; i < this.n; i++) {\n      sum += this.array[i][0]*matrix.array[i][0];\n    }\n    return new Matrix([[sum]]);\n  }\n\n  // appends a row of 1s to the top of a matrix\n  addBias() {\n    let array = this.array.slice();\n    array.unshift(new Array(this.m).fill(1));\n    return new Matrix(array);\n  }\n\n  // returns 2 array with dim n x m\n  static emptyMatrix(n,m) {\n    let array = new Array(n);\n    for (var i = 0; i < n; i++) {\n      array[i] = new Array(m).fill(0);\n    }\n    return new Matrix(array);\n  }\n\n  // creates identity matrix of dim nxn\n  static identity(n){\n    let array = new Array(n);\n    for (var i = 0; i < n; i++) {\n      array[i] = new Array(n).fill(0);\n    }\n    for (var i = 0; i < n; i++) {\n      array[i][i] = 1;\n    }\n    return new Matrix(array);\n  }\n\n  static vector(n,v){\n    let array = new Array(n).fill([v]);\n    return new Matrix(array);\n  }\n\n  static randomMatrix(n,m) {\n    let array = new Array(n);\n    let row;\n    for (var i = 0; i < n; i++) {\n      row = [];\n      for (var j = 0; j < m; j++) {\n        row.push(Math.random());\n      }\n      array[i] = row;\n    }\n    return new Matrix(array);\n  }\n}\n\nmodule.exports = Matrix;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/matrix.js\n// module id = 3\n// module chunks = 0","const Activation = {\n  \"sigmoid\" : (n) => {\n    return 1/(1+Math.exp(-n))\n  }\n}\n\nmodule.exports = Activation\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/activation.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}